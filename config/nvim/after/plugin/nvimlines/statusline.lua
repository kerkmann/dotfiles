-- local conditions = L "heirline.conditions"
-- local utils = L "heirline.utils"
--
-- local ViMode = {
--   -- get vim current mode, this information will be required by the provider
--   -- and the highlight functions, so we compute it only once per component
--   -- evaluation and store it as a component attribute
--   init = function(self)
--     self.mode = vim.fn.mode(1) -- :h mode()
--
--     -- execute this only once, this is required if you want the ViMode
--     -- component to be updated on operator pending mode
--     if not self.once then
--       vim.api.nvim_create_autocmd("ModeChanged", {
--         pattern = "*:*o",
--         command = 'redrawstatus'
--       })
--       self.once = true
--     end
--   end,
--   -- Now we define some dictionaries to map the output of mode() to the
--   -- corresponding string and color. We can put these into `static` to compute
--   -- them at initialisation time.
--   static = {
--     mode_names = { -- change the strings if you like it vvvvverbose!
--       n = "🄽",
--       no = "🄽?",
--       nov = "🄽?",
--       noV = "🄽?",
--       ["no\22"] = "🄽?",
--       niI = "Ni",
--       niR = "Nr",
--       niV = "Nv",
--       nt = "Nt",
--       v = "V",
--       vs = "Vs",
--       V = "V_",
--       Vs = "Vs",
--       ["\22"] = "^V",
--       ["\22s"] = "^V",
--       s = "S",
--       S = "S_",
--       ["\19"] = "^S",
--       i = "I",
--       ic = "Ic",
--       ix = "Ix",
--       R = "R",
--       Rc = "Rc",
--       Rx = "Rx",
--       Rv = "Rv",
--       Rvc = "Rv",
--       Rvx = "Rv",
--       c = "C",
--       cv = "Ex",
--       r = "...",
--       rm = "M",
--       ["r?"] = "?",
--       ["!"] = "!",
--       t = "T",
--     },
--     mode_colors = {
--       n = "red",
--       i = "green",
--       v = "cyan",
--       V = "cyan",
--       ["\22"] = "cyan",
--       c = "orange",
--       s = "purple",
--       S = "purple",
--       ["\19"] = "purple",
--       R = "orange",
--       r = "orange",
--       ["!"] = "red",
--       t = "red",
--     }
--   },
--   -- We can now access the value of mode() that, by now, would have been
--   -- computed by `init()` and use it to index our strings dictionary.
--   -- note how `static` fields become just regular attributes once the
--   -- component is instantiated.
--   -- To be extra meticulous, we can also add some vim statusline syntax to
--   -- control the padding and make sure our string is always at least 2
--   -- characters long. Plus a nice Icon.
--   provider = function(self)
--     return "%4(" .. self.mode_names[self.mode] .. "%4)"
--   end,
--   -- Same goes for the highlight. Now the foreground will change according to the current mode.
--   hl = function(self)
--     local mode = self.mode:sub(1, 1) -- get only the first mode character
--     return { fg = self.mode_colors[mode], bold = true, }
--   end,
--   -- Re-evaluate the component only on ModeChanged event!
--   -- This is not required in any way, but it's there, and it's a small
--   -- performance improvement.
--   update = {
--     "ModeChanged",
--   },
-- }
--
-- local Git = {
--   condition = conditions.is_git_repo,
--
--   init = function(self)
--     self.status_dict = vim.b.gitsigns_status_dict
--     self.has_changes = self.status_dict.added ~= 0 or self.status_dict.removed ~= 0 or self.status_dict.changed ~= 0
--   end,
--
--   hl = { fg = "orange" },
--
--
--   { -- git branch name
--     provider = function(self)
--       return " " .. self.status_dict.head
--     end,
--     hl = { bold = true }
--   },
--   -- You could handle delimiters, icons and counts similar to Diagnostics
--   {
--     condition = function(self)
--       return self.has_changes
--     end,
--     provider = "("
--   },
--   {
--     provider = function(self)
--       local count = self.status_dict.added or 0
--       return count > 0 and (vim.fn.sign_getdefined("GitSignsLineColAdd")[1].text .. count)
--     end,
--     hl = { fg = utils.get_highlight("GitSignsAdd").fg },
--   },
--   {
--     provider = function(self)
--       local count = self.status_dict.removed or 0
--       return count > 0 and (vim.fn.sign_getdefined("GitSignsLineColDelete")[1].text .. count)
--     end,
--     hl = { fg = utils.get_highlight("GitSignsDelete").fg },
--   },
--   {
--     provider = function(self)
--       local count = self.status_dict.changed or 0
--       return count > 0 and (vim.fn.sign_getdefined("GitSignsLineColChange")[1].text .. count)
--     end,
--     hl = { fg = utils.get_highlight("GitSignsChange").fg },
--   },
--   {
--     condition = function(self)
--       return self.has_changes
--     end,
--     provider = ")",
--   },
-- }
--
--
-- local statusline = {}
--
-- table.insert(statusline, ViMode)
-- table.insert(statusline, Git)
--
-- return statusline
